<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DogSight — Live Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #0b0b0c;
      color: #eaeaea;
    }

    header {
      padding: 12px 16px;
      font-weight: 600;
    }

    #wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 12px;
    }

    video {
      width: min(100vw, 900px);
      height: auto;
      background: #111;
      border-radius: 12px;
    }

    #status {
      opacity: .8;
      font-size: 14px;
    }
  </style>

  <!-- 1) Firebase SDKs (compat) -->
  <script defer src="https://www.gstatic.com/firebasejs/10.14.0/firebase-app-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.14.0/firebase-functions-compat.js"></script>
  <script defer src="/__/firebase/init.js?useEmulator=false"></script>

</head>

<body>
  <header>DogSight — Live Viewer</header>
  <div id="wrap">
    <div id="status">Initializing…</div>
    <video id="remote" autoplay playsinline controls muted></video>
  </div>

  <!-- 3) Your viewer code runs AFTER init (no defer here) -->
  <script>
    // Wait until Hosting auto-init has created the default app
    function waitForFirebaseReady(cb) {
      if (window.firebase && firebase.apps && firebase.apps.length) return cb();
      setTimeout(() => waitForFirebaseReady(cb), 50);
    }

    waitForFirebaseReady(() => {
    const functions = firebase.app().functions('us-central1');
    const call = (name, payload) => functions.httpsCallable(name)(payload).then(r => r.data);

    const iceServers = [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:stun1.l.google.com:19302" },
      // TURN server for internet streaming (free public TURN server)
      { urls: "turn:openrelay.metered.ca:443", username: "openrelayproject", credential: "openrelayproject" },
      { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelayproject", credential: "openrelayproject" }
    ];

    const parts = location.pathname.split('/').filter(Boolean);
    const userId    = parts[1];
    const sessionId = parts[2];
    const tokenId   = new URLSearchParams(location.search).get('t');

    const videoEl  = document.getElementById('remote');
    const statusEl = document.getElementById('status');

    let pc = null, hostIdx = 0;

    // >>> ADD THIS: viewer heartbeat every 3s
    const heartbeat = setInterval(() => {
      call('viewerPing', { tokenId, userId, sessionId }).catch(()=>{});
    }, 3000);
    // optional: best-effort ping on unload
    window.addEventListener('beforeunload', () => {
      clearInterval(heartbeat);
      call('viewerPing', { tokenId, userId, sessionId }).catch(()=>{});
    });
    // <<< END ADD

    (async function main(){
      if (!userId || !sessionId || !tokenId) { statusEl.textContent = "Invalid link."; return; }
      statusEl.textContent = "Connecting…";

      pc = new RTCPeerConnection({ iceServers });

      pc.ontrack = (e) => { videoEl.srcObject = e.streams[0]; statusEl.textContent = "Streaming"; };
      pc.onconnectionstatechange = () => { if (pc.connectionState === 'failed') statusEl.textContent = "Connection failed (refresh?)"; };

      pc.onicecandidate = async (e) => {
        if (e.candidate) {
          try { await call('postViewerCandidate', { tokenId, userId, sessionId, candidate: e.candidate.toJSON() }); }
          catch (err) { console.warn('postViewerCandidate failed', err); }
        }
      };

      const poll = async () => {
        try {
          const sig = await call('getSignaling', { tokenId, userId, sessionId, sinceIdx: hostIdx });
          hostIdx = sig.nextIdx || hostIdx;

          if (sig.offer && pc.signalingState === 'stable' && !pc.remoteDescription) {
            await pc.setRemoteDescription(new RTCSessionDescription(sig.offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await call('postAnswer', { tokenId, userId, sessionId, answer: { type: answer.type, sdp: answer.sdp } });
          }

          if (Array.isArray(sig.hostCandidates)) {
            for (const c of sig.hostCandidates) {
              try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch {}
            }
          }

          if (pc.connectionState === 'connected' || pc.connectionState === 'completed') return;
        } catch (e) {
          console.warn('getSignaling error', e);
        }
        setTimeout(poll, 1000);
      };
      poll();
    })();
  });
  </script>

</body>

</html>